-- Generated by Oracle SQL Developer Data Modeler 20.4.0.374.0801
--   at:        2022-06-01 21:51:50 EEST
--   site:      Oracle Database 11g
--   type:      Oracle Database 11g



-- predefined type, no DDL - MDSYS.SDO_GEOMETRY

-- predefined type, no DDL - XMLTYPE

CREATE TABLE pacienti (
    id_pacient   NUMBER(3) NOT NULL,
    nume         VARCHAR2(20) NOT NULL,
    prenume      VARCHAR2(20) NOT NULL,
    apartinator  NUMBER(3)
)
LOGGING;

ALTER TABLE pacienti
    ADD CONSTRAINT nume_ck CHECK ( length(nume) > 1 );

ALTER TABLE pacienti
    ADD CONSTRAINT prenume_ck CHECK ( length(prenume) > 1 );

ALTER TABLE pacienti ADD CONSTRAINT pacienti_pk PRIMARY KEY ( id_pacient );

CREATE TABLE analize (
    id_analiza              NUMBER(3) NOT NULL,
    categorie               VARCHAR2(40) NOT NULL,
    data_recoltarii         DATE NOT NULL,
    data_rezultatului       DATE NOT NULL,
    medici_id_medic         NUMBER(3) NOT NULL,
    asistente_id_asistenta  NUMBER(3) NOT NULL
)
LOGGING;

ALTER TABLE analize
    ADD CONSTRAINT categorie_ck CHECK ( length(categorie) > 1 );

ALTER TABLE analize ADD CONSTRAINT data_rezultatului CHECK ( data_rezultatului >= data_recoltarii );

ALTER TABLE analize ADD CONSTRAINT analize_pk PRIMARY KEY ( id_analiza );

CREATE OR REPLACE PACKAGE Package_delete AS 
    v_id_pacient pacienti.id_pacient%TYPE;
    v_id_analiza analize.id_analiza%TYPE;
    
    PROCEDURE delete_detalii_pacient
        (v_id_pacient IN NUMBER) IS
    BEGIN
        DELETE FROM detalii_pacienti WHERE pacienti_id_pacient=v_id_pacient;
    END delete_detalii_pacient;
    
    
    PROCEDURE delete_pacient
        (v_nume	IN	VARCHAR2,
         v_prenume	IN	VARCHAR2) IS
    BEGIN
        SELECT id_pacient INTO v_id_pacient FROM pacienti WHERE nume=v_nume AND prenume=v_prenume;
        delete_detalii_pacient(v_id_pacient);
        delete_pacienti_analize_fk1(v_id_pacient);
        
        DELETE FROM pacienti WHERE nume=v_nume AND prenume=v_prenume;
    END delete_pacient;
    
    PROCEDURE delete_pacienti_analize_fk1
        (v_id_pacient	IN	NUMBER) IS
     BEGIN
        DELETE FROM pacienti_analize_fk WHERE pacienti_id_pacient = v_id_pacient;
    END delete_pacienti_analize_fk1;
    
    
    PROCEDURE delete_detalii_analiza
        (v_id_analiza	IN	NUMBER) IS
    BEGIN
        DELETE FROM detalii_analize WHERE analize_id_analiza = v_id_analiza;
    END delete_detalii_analiza;


    PROCEDURE delete_pacienti_analize_fk2
        (v_id_analiza	IN	NUMBER) IS
    BEGIN
        DELETE FROM pacienti_analize_fk WHERE analize_id_analiza = v_id_analiza;
    END delete_pacienti_analize_fk2;
    
    
    PROCEDURE delete_analiza
        (v_categorie IN	VARCHAR2) IS
    BEGIN
        SELECT id_analiza INTO v_id_analiza FROM analize WHERE categorie=v_categorie;--imi da id-ul categoriei de sters din detalii_analize
        --dbms_output.put_line('aici: ' || v_id_analiza);
        delete_detalii_analiza(v_id_analiza);--vreau sa sterg toate care au id-ul ala
        delete_pacienti_analize_fk2(v_id_analiza);
        
        DELETE FROM analize WHERE categorie=v_categorie;
    END delete_analiza; 
    
    PROCEDURE delete_pacient_cu_analizele_sale
        (v_nume IN	VARCHAR2,
        v_prenume IN	VARCHAR2) IS
    BEGIN
         SELECT id_pacient INTO v_id_pacient FROM pacienti WHERE nume=v_nume AND prenume=v_prenume;
         SELECT id_analiza INTO v_id_analiza FROM pacienti p, analize a, pacienti_analize_fk pa WHERE p.id_pacient=pa.pacienti_id_pacient AND pa.analize_id_analiza=a.id_analiza AND p.id_pacient=v_id_pacient;
        
        delete_pacient(v_nume, v_prenume);
        delete_detalii_analiza(v_id_analiza);
        delete_pacienti_analize_fk2(v_id_analiza);
        
        DELETE FROM analize WHERE id_analiza=v_id_analiza;
    END delete_pacient_cu_analizele_sale;
END;
/

CREATE TABLE medici (
    id_medic    NUMBER(3) NOT NULL,
    nume        VARCHAR2(20) NOT NULL,
    prenume     VARCHAR2(30) NOT NULL,
    cod_parafa  VARCHAR2(6) NOT NULL
)
LOGGING;

ALTER TABLE medici
    ADD CONSTRAINT numem_ck CHECK ( length(nume) > 1 );

ALTER TABLE medici
    ADD CONSTRAINT prenumem_ck CHECK ( length(prenume) > 1 );

ALTER TABLE medici ADD CONSTRAINT medici_pk PRIMARY KEY ( id_medic );

CREATE TABLE asistente (
    id_asistenta  NUMBER(3) NOT NULL,
    nume          VARCHAR2(20) NOT NULL,
    prenume       VARCHAR2(30) NOT NULL
)
LOGGING;

ALTER TABLE asistente
    ADD CONSTRAINT numea_ck CHECK ( length(nume) > 1 );

ALTER TABLE asistente
    ADD CONSTRAINT prenumea_ck CHECK ( length(prenume) > 1 );

ALTER TABLE asistente ADD CONSTRAINT asistente_pk PRIMARY KEY ( id_asistenta );

CREATE OR REPLACE PACKAGE Package_insert AS 
    v_medic_id medici.id_medic%TYPE;
    v_asistenta_id asistente.id_asistenta%TYPE;
    v_pacient_id pacienti.id_pacient%TYPE;
    v_analize_id analize.id_analiza%TYPE;
    
    PROCEDURE add_medic
        (v_nume	IN	VARCHAR2,
         v_prenume	IN	VARCHAR2,
         v_cod_parafa IN VARCHAR2) IS
    BEGIN
      INSERT INTO medici (nume, prenume, cod_parafa)
      VALUES (v_nume, v_prenume, v_cod_parafa);
    END add_medic;
    
    PROCEDURE add_asistenta
        (v_nume	IN	VARCHAR2,
         v_prenume	IN	VARCHAR2) IS
    BEGIN
      INSERT INTO asistente (nume, prenume)
      VALUES (v_nume, v_prenume);
    END add_asistenta;
    
    PROCEDURE add_pacient
        (v_nume	IN	VARCHAR2,
         v_prenume	IN	VARCHAR2,
         v_apartinator IN NUMBER) 
    IS
         e_pacient_nume EXCEPTION; 
         e_pacient_prenume EXCEPTION; 
         pragma exception_init(e_pacient_nume, -20005);
         pragma exception_init(e_pacient_prenume, -20006);
    BEGIN
        IF v_nume IS NULL OR length(v_nume) <= 1 or length(v_nume) > 30 THEN
            RAISE e_pacient_nume;
        END IF;
        
        IF v_prenume IS NULL OR length(v_prenume) <= 1 or length(v_prenume) > 30 THEN
            RAISE e_pacient_prenume;
        END IF;
        
        INSERT INTO pacienti (nume, prenume, apartinator)
        VALUES (v_nume, v_prenume, v_apartinator);
    EXCEPTION
        WHEN e_pacient_nume THEN
            dbms_output.put_line('Nu s-a respectat constrangerea bazei de date! Campul nume trebuie sa fie diferit de null, cu dimensiunea mai mare decat 1 si mai mica decat 20!!'); 
        WHEN e_pacient_prenume THEN
            dbms_output.put_line('Nu s-a respectat constrangerea bazei de date! Campul prenume trebuie sa fie diferit de null, cu dimensiunea mai mare decat 1 si mai mica decat 20!!'); 
        WHEN OTHERS THEN
            dbms_output.put_line('S-au mai produs alte erori la inserarea unui pacient.');
    END add_pacient;
    
    PROCEDURE add_detalii_pacient
        (v_data_nasterii IN DATE,
         v_CNP IN NUMBER,
         v_gen IN CHAR,
         v_telefon IN VARCHAR2,
         v_email IN VARCHAR2,
         v_pacienti_n IN VARCHAR2,
         v_pacienti_p IN VARCHAR2) 
    IS
         e_data_nasterii EXCEPTION; 
         e_CNP EXCEPTION; 
         e_gen EXCEPTION; 
         pragma exception_init(e_data_nasterii, -20007);
         pragma exception_init(e_CNP, -20008);
         pragma exception_init(e_gen, -20009);
    BEGIN
        IF v_data_nasterii IS NULL THEN
            RAISE e_data_nasterii;
        END IF;
        
        IF v_CNP IS NULL THEN
            RAISE e_CNP;
        END IF;
        
        IF v_gen IS NULL THEN
            RAISE e_gen;
        END IF;
        
        SELECT id_pacient INTO v_pacient_id FROM pacienti WHERE nume = v_pacienti_n AND prenume = v_pacienti_p;
        
        INSERT INTO Detalii_Pacienti(data_nasterii, CNP, gen, telefon, email, pacienti_id_pacient) 
        VALUES(v_data_nasterii, v_CNP, v_gen, v_telefon, v_email, v_pacient_id);
    EXCEPTION
        WHEN e_data_nasterii THEN
            dbms_output.put_line('Nu s-a respectat constrangerea bazei de date! Campul data nasterii trebuie sa fie diferit de null!'); 
        WHEN e_CNP THEN
            dbms_output.put_line('Nu s-a respectat constrangerea bazei de date! Campul CNP trebuie sa fie diferit de null!'); 
        WHEN e_gen THEN
            dbms_output.put_line('Nu s-a respectat constrangerea bazei de date! Campul gen trebuie sa fie diferit de null!'); 
        WHEN OTHERS THEN
            dbms_output.put_line('S-au mai produs alte erori la inserarea unui detaliu pentru pacient.');
    END add_detalii_pacient;
    
    PROCEDURE add_analiza
        (v_categorie IN	VARCHAR2,
         v_data_recoltarii	IN	DATE,
         v_data_rezultatului IN	DATE,
         v_medic_n IN VARCHAR2,
         v_asistenta_n IN VARCHAR2)
    IS
         e_add_analiza_date EXCEPTION; 
         e_add_analiza_categorie EXCEPTION; 
         pragma exception_init(e_add_analiza_date, -20000);
         pragma exception_init(e_add_analiza_categorie, -20001);
         v_flag BOOLEAN;
    BEGIN
        SELECT id_medic INTO v_medic_id FROM medici WHERE nume = v_medic_n;
        SELECT id_asistenta INTO v_asistenta_id FROM asistente WHERE nume = v_asistenta_n;
       
        IF v_categorie IS NULL THEN
            RAISE e_add_analiza_categorie;
        END IF;
        
        v_flag := validare_date(v_data_recoltarii, v_data_rezultatului);
        IF  v_flag = TRUE THEN
            RAISE e_add_analiza_date;
        ELSE
            INSERT INTO analize (categorie, data_recoltarii, data_rezultatului, medici_id_medic, asistente_id_asistenta)
            VALUES (v_categorie, v_data_recoltarii, v_data_rezultatului, v_medic_id, v_asistenta_id);
        END IF;
    EXCEPTION
        WHEN e_add_analiza_date THEN
            dbms_output.put_line('Datele introduse sunt incorecte! Data rezultatului trebuie sa fie mai mare sau egala cu data recolatrii!'); 
        WHEN e_add_analiza_categorie THEN
            dbms_output.put_line('Nu s-a respectat constrangerea bazei de date! Campul categorie trebuie sa fie diferit de null!'); 
        WHEN OTHERS THEN
            dbms_output.put_line('S-au mai produs alte erori la inserarea unei analize.');
    END add_analiza;
    
    PROCEDURE add_detalii_analiza	
        (v_nume_analiza IN	VARCHAR2,
         v_valoare_rezultata	IN	NUMBER,
         v_interval_referinta IN VARCHAR2,
         v_analize_categorie IN VARCHAR2, 
         v_valabilitate IN NUMBER, 
         v_data_recoltarii IN DATE,
         v_data_rezultatului IN DATE) 
    IS
         e_add_detaliu_analiza_nume EXCEPTION; 
         e_add_detaliu_analiza_val_rez EXCEPTION; 
         e_add_detaliu_analiza_interval EXCEPTION; 
         
         pragma exception_init(e_add_detaliu_analiza_nume, -20002);
         pragma exception_init(e_add_detaliu_analiza_val_rez, -20003);
         pragma exception_init(e_add_detaliu_analiza_interval, -20004);
    BEGIN
    
        IF v_nume_analiza IS NULL OR length(v_nume_analiza) <= 1 OR length(v_nume_analiza) > 30 THEN
            RAISE e_add_detaliu_analiza_nume;
        END IF;
        IF v_valoare_rezultata IS NULL OR v_valoare_rezultata <= 0 OR v_valoare_rezultata > 999 THEN
            RAISE e_add_detaliu_analiza_val_rez;
        END IF;
        IF v_interval_referinta IS NULL OR length(v_interval_referinta) <= 1 OR length(v_interval_referinta) > 30 THEN
            RAISE e_add_detaliu_analiza_interval;
        END IF;
        
        SELECT id_analiza INTO v_analize_id FROM analize WHERE categorie = v_analize_categorie AND data_recoltarii = v_data_recoltarii AND data_rezultatului=v_data_rezultatului;

        INSERT INTO Detalii_Analize (nume_analiza, valoare_rezultata, interval_referinta, analize_id_analiza, valabilitate)
        VALUES (v_nume_analiza, v_valoare_rezultata, v_interval_referinta, v_analize_id, v_valabilitate);
        
     EXCEPTION
        WHEN e_add_detaliu_analiza_nume THEN
            dbms_output.put_line('Nu s-a respectat constrangerea bazei de date! Campul nume analiza trebuie sa fie diferit de null, cu dimensiunea mai mare decat 1 si mai mica decat 30 de caractere!'); 
        WHEN e_add_detaliu_analiza_val_rez THEN
            dbms_output.put_line('Nu s-a respectat constrangerea bazei de date! Campul valoare rezultata trebuie sa fie diferit de null, mai mare decat 0 si mai mic decat 999!'); 
        WHEN e_add_detaliu_analiza_interval THEN
            dbms_output.put_line('Nu s-a respectat constrangerea bazei de date! Campul interval referinta trebuie sa fie diferit de null, cu dimensiunea mai mare decat 1 si mai mica decat 30 de caractere!'); 
        WHEN OTHERS THEN
            dbms_output.put_line('S-au mai produs alte erori la inserarea unui detaliu pentru analize.');
    END add_detalii_analiza;   
END;
/

CREATE OR REPLACE PACKAGE Package_show AS 
    PROCEDURE afisare_pacienti IS
        CURSOR c1 IS
        SELECT * FROM pacienti;
    BEGIN
        dbms_output.put_line('Datele din pacienti: ');
        FOR val IN c1 LOOP
            dbms_output.put_line('id_pacient: ' || val.id_pacient || ', nume: ' || val.nume || ', prenume: ' || val.prenume || ', apartinator: ' || nvl(val.apartinator, 0) || '.'); 
        END LOOP;
    END afisare_pacienti;
    
    PROCEDURE afisare_detalii_pacienti IS
        CURSOR c2 IS
        SELECT * FROM detalii_pacienti;
    BEGIN
        dbms_output.put_line('Datele din detalii pacienti: ');
        FOR val IN c2 LOOP
            dbms_output.put_line('id_detaliu: ' || val.id_detaliu || ', data nasterii: ' || val.data_nasterii || ', CNP: ' || val.CNP || ', gen: ' || val.gen || ', telefon: ' || val.telefon || ', email: ' || val.email || ', pacienti_id_pacient: ' || val.pacienti_id_pacient || '.'); 
        END LOOP;
    END afisare_detalii_pacienti;
    
    PROCEDURE afisare_analize IS
        CURSOR c3 IS
        SELECT * FROM analize;
    BEGIN
        dbms_output.put_line('Datele din analize: ');
        FOR val IN c3 LOOP
            dbms_output.put_line('id_analiza: ' || val.id_analiza || ', data recoltarii: ' || val.data_recoltarii || ', data rezultatului: ' || val.data_rezultatului || ', medici_id_mdic: ' || val.medici_id_medic || ', asistente_id_asistenta: ' || val.asistente_id_asistenta || '.'); 
        END LOOP;
    END afisare_analize;
    
    PROCEDURE afisare_detalii_analize IS
        CURSOR c4 IS
        SELECT * FROM detalii_analize;
    BEGIN
        dbms_output.put_line('Datele din detalii analize: ');
        FOR val IN c4 LOOP
            dbms_output.put_line('id_detaliu: ' || val.id_detaliu || ', nume analiza: ' || val.nume_analiza || ', valoarea rezultatului: ' || val.valoare_rezultata || ', interval referinta: ' || val.interval_referinta || ', analize_id_analiza: ' || val.analize_id_analiza || ', valabilitate: ' || val.valabilitate || '.'); 
        END LOOP;
    END afisare_detalii_analize;
    
    PROCEDURE afisare_pacienti_si_detalii IS
        CURSOR c5 IS
        SELECT nume, prenume, data_nasterii, CNP, gen, telefon, email FROM pacienti p, detalii_pacienti pd WHERE p.id_pacient=pd.pacienti_id_pacient;
    BEGIN
        dbms_output.put_line('Pacientii cu detaliile lor: ');
        FOR val IN c5 LOOP
            
            dbms_output.put_line('Pacientul cu numele: ' || val.nume || ' si prenumele: ' || val.prenume || ' are urmatoarele date: data nasterii: ' || val.data_nasterii || ', CNP: ' || val.CNP || ', gen: ' || val.gen || ', telefon: ' || val.telefon || ', email: ' || val.email || '.'); 
        END LOOP;
    END afisare_pacienti_si_detalii;
    
    PROCEDURE afisare_analize_si_detalii IS
        CURSOR c6 IS
        SELECT categorie, data_recoltarii, data_rezultatului, nume_analiza, valoare_rezultata, interval_referinta FROM analize a, detalii_analize ad WHERE a.id_analiza=ad.analize_id_analiza;
    BEGIN
        dbms_output.put_line('Pacientii cu detaliile lor: ');
        FOR val IN c6 LOOP
            dbms_output.put_line('Analiza ce are categoria: ' || val.categorie || ', data_recoltarii: ' || val.data_recoltarii || ' si data_rezultatului: ' || val.data_rezultatului || ' are urmatoarele detalii: numele analizei: ' || val.nume_analiza || ', valoarea rezultata: ' || val.valoare_rezultata || ' si intervalul de referinta: ' || val.interval_referinta || '.'); 
        END LOOP;
    END afisare_analize_si_detalii;
END;
/

CREATE TABLE detalii_pacienti (
    id_detaliu           NUMBER(3) NOT NULL,
    data_nasterii        DATE NOT NULL,
    cnp                  NUMBER(13) NOT NULL,
    gen                  CHAR(1) NOT NULL,
    telefon              VARCHAR2(10),
    email                VARCHAR2(40),
    pacienti_id_pacient  NUMBER(3) NOT NULL
)
LOGGING;

ALTER TABLE detalii_pacienti
    ADD CONSTRAINT gen_ck CHECK ( gen IN ( 'F', 'M' ) );

ALTER TABLE detalii_pacienti
    ADD CONSTRAINT telefon_ck CHECK ( REGEXP_LIKE ( telefon,
                                                    '[0-9]{10}' ) );

ALTER TABLE detalii_pacienti
    ADD CONSTRAINT email_ck CHECK ( REGEXP_LIKE ( email,
                                                  '[a-z0-9._%-]+@[a-z0-9._%-]+\.[a-z]{2,4}' ) );

CREATE UNIQUE INDEX detalii_pacienti__idx ON
    detalii_pacienti (
        pacienti_id_pacient
    ASC )
        LOGGING;

ALTER TABLE detalii_pacienti ADD CONSTRAINT detalii_pacienti_pk PRIMARY KEY ( id_detaliu );

ALTER TABLE detalii_pacienti ADD CONSTRAINT detalii_pacienti_cnp_un UNIQUE ( cnp );

CREATE OR REPLACE PACKAGE Package_tranzactie AS 
    v_pacient_id pacienti.id_pacient%TYPE;
    v_pacient_nume pacienti.nume%TYPE;
    v_pacient_prenume pacienti.prenume%TYPE;
    v_pacienti_id_pacient detalii_pacienti.pacienti_id_pacient%TYPE := NULL;
    
    PROCEDURE insert_detalii_pacient
        (v_data_nasterii IN DATE,
         v_CNP IN NUMBER,
         v_gen IN CHAR,
         v_telefon IN VARCHAR2,
         v_email IN VARCHAR2,
         v_pacienti_n IN VARCHAR2,
         v_pacienti_p IN VARCHAR2) IS
    BEGIN
        --fac legatura de fk intre tabela detalii_pacienti si tabela pacienti
        SELECT id_pacient INTO v_pacient_id FROM pacienti WHERE nume = v_pacienti_n AND prenume = v_pacienti_p;
        
        --verific daca mai are cineva numarul de telefon pe care vreau sa introduc pentru pacientul meu si daca da imi pun id-ul sau in variabila v_pacienti_id_pacient
        SELECT pacienti_id_pacient INTO v_pacienti_id_pacient FROM detalii_pacienti WHERE telefon = v_telefon;
        
        --daca imi gaseste un id imi cauta numele si prenumele pacientului ca sa ii fac update la campul apartiantor cu id-ul pacientului inserat acum
        IF v_pacienti_id_pacient != 0 THEN
            INSERT INTO Detalii_Pacienti(data_nasterii, CNP, gen, telefon, email, pacienti_id_pacient) 
            VALUES(v_data_nasterii, v_CNP, v_gen, v_telefon, v_email, v_pacient_id);
        ELSE
            SELECT nume, prenume INTO v_pacient_nume, v_pacient_prenume FROM pacienti WHERE id_pacient = v_pacienti_id_pacient;
            
            INSERT INTO Detalii_Pacienti(data_nasterii, CNP, gen, telefon, email, pacienti_id_pacient) 
            VALUES(v_data_nasterii, v_CNP, v_gen, v_telefon, v_email, v_pacient_id);
            
            update_package.update_apartinator_pacient(v_pacient_nume,v_pacient_prenume , v_pacienti_n, v_pacienti_p);
        END IF;   
    EXCEPTION
        WHEN NO_DATA_FOUND then
            v_pacienti_id_pacient := 0;
            INSERT INTO Detalii_Pacienti(data_nasterii, CNP, gen, telefon, email, pacienti_id_pacient) 
            VALUES(v_data_nasterii, v_CNP, v_gen, v_telefon, v_email, v_pacient_id);
    END insert_detalii_pacient;
    
    PROCEDURE tranzactie_procedure(
         v_nume1 IN VARCHAR2,
         v_prenume1 IN VARCHAR2,
         v_apartinator1 IN NUMBER,
         v_data_nasterii1 IN DATE,
         v_CNP1 IN NUMBER,
         v_gen1 IN CHAR,
         v_telefon1 IN VARCHAR2,
         v_email1 IN VARCHAR2,
         
         v_nume2 IN VARCHAR2,
         v_prenume2 IN VARCHAR2,
         v_apartinator2 IN NUMBER,
         v_data_nasterii2 IN DATE,
         v_CNP2 IN NUMBER,
         v_gen2 IN CHAR,
         v_telefon2 IN VARCHAR2,
         v_email2 IN VARCHAR2) IS
    BEGIN
        --COMMIT;
        SET TRANSACTION NAME 'add_pacient_with_same_phone_number';
        SAVEPOINT before_insert_first_pacient;
        
        insert_package.add_pacient(v_nume1, v_prenume1, v_apartinator1);
        SAVEPOINT after_insert_first_pacient;
        
        insert_detalii_pacient(v_data_nasterii1, v_CNP1, v_gen1, v_telefon1, v_email1, v_nume1, v_prenume1);
        SAVEPOINT after_insert_details_for_first_pacient;
          
        insert_package.add_pacient(v_nume2, v_prenume2, v_apartinator2);
        SAVEPOINT after_insert_second_pacient;
        
        insert_detalii_pacient(v_data_nasterii2, v_CNP2, v_gen2, v_telefon2, v_email2, v_nume2, v_prenume2);
        SAVEPOINT after_insert_details_for_second_pacient;
          
        SAVEPOINT before_update_apartinator;
        update_package.update_apartinator_pacient(v_nume1, v_prenume1,v_nume2, v_prenume2); 
        
        --ROLLBACK TO SAVEPOINT before_insert_first_pacient;
        --COMMIT;
    EXCEPTION
        WHEN OTHERS THEN
            dbms_output.put_line('S-au mai produs alte erori! Se face ROLLBACK catre SAVEPOINT-UL before_insert_first_pacient');
            ROLLBACK TO SAVEPOINT before_insert_first_pacient;
    END tranzactie_procedure;
END;
/

CREATE OR REPLACE PACKAGE Package_update AS 
    v_apartinator_id pacienti.apartinator%TYPE;
    v_id_pacient detalii_pacienti.id_detaliu%TYPE;
    
    PROCEDURE update_nume_pacient
        (v_nume	IN	VARCHAR2,
         v_prenume	IN	VARCHAR2,
         v_nume_nou IN VARCHAR2)
    IS
        e_update_nume_nou EXCEPTION; 
        pragma exception_init(e_update_nume_nou, -20010);
    BEGIN
        IF v_nume_nou IS NULL THEN
            RAISE e_update_nume_nou;
        END IF;
        UPDATE pacienti SET nume=v_nume_nou WHERE nume=v_nume AND prenume=v_prenume;
    EXCEPTION
        WHEN e_update_nume_nou THEN
            dbms_output.put_line('Nu s-a respectat constrangerea bazei de date! Campul nume trebuie sa fie diferit de null!');
        WHEN OTHERS THEN
            dbms_output.put_line('S-au mai produs alte erori la modificarea numelui unui pacient.');
    END update_nume_pacient;
    
    PROCEDURE update_apartinator_pacient
        (v_nume	IN	VARCHAR2,
         v_prenume	IN	VARCHAR2,
         v_nume2	IN	VARCHAR2,
         v_prenume2	IN	VARCHAR2) IS
    BEGIN
        SELECT id_pacient INTO v_apartinator_id FROM pacienti WHERE nume=v_nume2 AND prenume=v_prenume2;--nume si prenume copil -> imi iau id-ul sau
        --dbms_output.put_line('aici: ' || v_apartinator_id);
        UPDATE pacienti SET apartinator = v_apartinator_id WHERE nume=v_nume AND prenume=v_prenume; --fac update la mama si ii trec la apartinator id-ul copilului
    END update_apartinator_pacient;
    
    PROCEDURE update_detalii_pacient_telefon
        (v_nume	IN	VARCHAR2,
         v_prenume	IN	VARCHAR2,
         v_telefon	IN	VARCHAR2) IS
    BEGIN
        SELECT id_pacient INTO v_id_pacient FROM pacienti WHERE nume=v_nume AND prenume=v_prenume;
        UPDATE detalii_pacienti SET telefon=v_telefon WHERE pacienti_id_pacient=v_id_pacient;
    END update_detalii_pacient_telefon;
    
    PROCEDURE update_detalii_pacient_email
        (v_nume	IN	VARCHAR2,
         v_prenume	IN	VARCHAR2,
         v_email	IN	VARCHAR2) IS
    BEGIN
        SELECT id_pacient INTO v_id_pacient FROM pacienti WHERE nume=v_nume AND prenume=v_prenume;
        UPDATE detalii_pacienti SET email=v_email WHERE pacienti_id_pacient=v_id_pacient;
    END update_detalii_pacient_email;
    
    PROCEDURE update_detalii_analize_valabilitate
        (v_nume_analiza	IN	VARCHAR2,
         v_valabilitate	IN	NUMBER) IS
    BEGIN
        UPDATE detalii_analize SET valabilitate=v_valabilitate WHERE nume_analiza=v_nume_analiza;
    END update_detalii_analize_valabilitate;
END;
/

CREATE OR REPLACE FUNCTION validare_date (
    v_data_recoltarii    DATE,
    v_data_rezultatului  DATE
) RETURN BOOLEAN AS
BEGIN
    IF v_data_recoltarii > v_data_rezultatului THEN
        RETURN true;
    ELSE
        RETURN false;
    END IF;
END;
/

CREATE TABLE detalii_analize (
    id_detaliu          NUMBER(3) NOT NULL,
    nume_analiza        VARCHAR2(30) NOT NULL,
    valoare_rezultata   NUMBER(3) NOT NULL,
    interval_referinta  VARCHAR2(30) NOT NULL,
    analize_id_analiza  NUMBER(3) NOT NULL,
    valabilitate        NUMBER(2) NOT NULL
)
LOGGING;

ALTER TABLE detalii_analize
    ADD CONSTRAINT nume_analiza_ck CHECK ( length(nume_analiza) > 1 );

ALTER TABLE detalii_analize ADD CONSTRAINT valoare_rezultata_ck CHECK ( valoare_rezultata > 0 );

ALTER TABLE detalii_analize
    ADD CONSTRAINT interval_ck CHECK ( length(interval_referinta) > 1 );

ALTER TABLE detalii_analize ADD CONSTRAINT detalii_analize_pk PRIMARY KEY ( id_detaliu );

CREATE TABLE pacienti_analize_fk (
    pacienti_id_pacient  NUMBER(3) NOT NULL,
    analize_id_analiza   NUMBER(3) NOT NULL
)
LOGGING;

ALTER TABLE pacienti_analize_fk ADD CONSTRAINT pacienti_analize_fk_pk PRIMARY KEY ( pacienti_id_pacient,
                                                                                    analize_id_analiza );

ALTER TABLE analize
    ADD CONSTRAINT analize_asistente_fk FOREIGN KEY ( asistente_id_asistenta )
        REFERENCES asistente ( id_asistenta )
    NOT DEFERRABLE;

ALTER TABLE analize
    ADD CONSTRAINT analize_medici_fk FOREIGN KEY ( medici_id_medic )
        REFERENCES medici ( id_medic )
    NOT DEFERRABLE;

ALTER TABLE detalii_analize
    ADD CONSTRAINT detalii_analize_analize_fk FOREIGN KEY ( analize_id_analiza )
        REFERENCES analize ( id_analiza )
    NOT DEFERRABLE;

ALTER TABLE detalii_pacienti
    ADD CONSTRAINT detalii_pacienti_pacienti_fk FOREIGN KEY ( pacienti_id_pacient )
        REFERENCES pacienti ( id_pacient )
    NOT DEFERRABLE;

ALTER TABLE pacienti_analize_fk
    ADD CONSTRAINT pacienti_analize_fk_analize FOREIGN KEY ( analize_id_analiza )
        REFERENCES analize ( id_analiza )
    NOT DEFERRABLE;

ALTER TABLE pacienti_analize_fk
    ADD CONSTRAINT pacienti_analize_fk_pacienti FOREIGN KEY ( pacienti_id_pacient )
        REFERENCES pacienti ( id_pacient )
    NOT DEFERRABLE;

CREATE OR REPLACE TRIGGER Trg_before_delete_pacient 
    BEFORE DELETE ON pacienti 
DECLARE 
    v_id_pacient pacienti.id_pacient%TYPE;
    CURSOR c1 IS 
    SELECT * FROM pacienti;
BEGIN
    IF DELETING THEN
        FOR val IN c1 LOOP
            v_id_pacient := val.id_pacient;
        END LOOP;
        --dbms_output.put_line(v_id_pacient);
    END IF;
    UPDATE pacienti SET apartinator=NULL
    WHERE apartinator=v_id_pacient;
END ;
/

CREATE OR REPLACE TRIGGER Trg_before_insert_Analiza_with_details 
    BEFORE INSERT ON detalii_analize 
    FOR EACH ROW 
DECLARE 
    v_nume_analiza_nou detalii_analize.nume_analiza%TYPE := :new.nume_analiza;
    v_analize_id_analiza_nou detalii_analize.analize_id_analiza%TYPE := :new.analize_id_analiza;
    v_data_recoltare_noua analize.data_recoltarii%TYPE;
    
    v_valabilitate detalii_analize.valabilitate%TYPE;
    v_data_recoltarii analize.data_recoltarii%TYPE;
   
    CURSOR c1 IS
    SELECT analize_id_analiza, valabilitate FROM detalii_analize WHERE nume_analiza = v_nume_analiza_nou;
BEGIN
    SELECT data_recoltarii INTO v_data_recoltare_noua FROM analize WHERE id_analiza=v_analize_id_analiza_nou; --data recoltarii noi
    dbms_output.put_line(v_data_recoltare_noua);
    
    FOR val IN c1 LOOP
        v_valabilitate := val.valabilitate;
        dbms_output.put_line(val.analize_id_analiza || ' si ' || val.valabilitate);
        SELECT data_recoltarii INTO v_data_recoltarii FROM analize WHERE id_analiza = val.analize_id_analiza; --data recoltarii vechi
        dbms_output.put_line(v_data_recoltarii);
        
        IF v_data_recoltare_noua - v_data_recoltarii < v_valabilitate THEN
            RAISE_APPLICATION_ERROR(-20508,'Termenul de valabilitate nerespectat! Analiza se face prea devreme!');
        END IF;
    END LOOP;
END ;
/

CREATE OR REPLACE TRIGGER Trg_before_update_phone_pacient 
    BEFORE UPDATE OF telefon ON detalii_pacienti 
DECLARE 
    CURSOR c1 IS 
    SELECT pacienti_id_pacient FROM detalii_pacienti WHERE telefon=detalii_pacienti.telefon;
    
    CURSOR c2 IS
    SELECT * FROM pacienti;
BEGIN
    IF UPDATING THEN
        FOR val IN c1 LOOP
            FOR v IN c2 LOOP
                IF val.pacienti_id_pacient = v.apartinator THEN
                    UPDATE pacienti SET apartinator=NULL
                    WHERE apartinator = val.pacienti_id_pacient;
                END IF;
            END LOOP;
        END LOOP;
    END IF;
END ;
/

CREATE OR REPLACE TRIGGER Trg_validare_date 
    BEFORE INSERT OR UPDATE ON analize 
    FOR EACH ROW 
BEGIN
  IF( :new.data_recoltarii > :new.data_rezultatului)
  THEN
    RAISE_APPLICATION_ERROR( -20001, 
          'Date invalide! Data recoltarii analizei trebuie sa fie mai mica sau egala cu data rezultatului!' || 
          to_char( :new.data_recoltarii, 'YYYY-MM-DD HH24:MI:SS' ) || ' ' ||  to_char( :new.data_rezultatului, 'YYYY-MM-DD HH24:MI:SS' ) );
  END IF;
END ;
/

CREATE SEQUENCE analize_id_analiza_seq START WITH 1 NOCACHE ORDER;

CREATE OR REPLACE TRIGGER analize_id_analiza_trg BEFORE
    INSERT ON analize
    FOR EACH ROW
    WHEN ( new.id_analiza IS NULL )
BEGIN
    :new.id_analiza := analize_id_analiza_seq.nextval;
END;
/

CREATE SEQUENCE asistente_id_asistenta_seq START WITH 1 NOCACHE ORDER;

CREATE OR REPLACE TRIGGER asistente_id_asistenta_trg BEFORE
    INSERT ON asistente
    FOR EACH ROW
    WHEN ( new.id_asistenta IS NULL )
BEGIN
    :new.id_asistenta := asistente_id_asistenta_seq.nextval;
END;
/

CREATE SEQUENCE detalii_analize_id_detaliu_seq START WITH 1 NOCACHE ORDER;

CREATE OR REPLACE TRIGGER detalii_analize_id_detaliu_trg BEFORE
    INSERT ON detalii_analize
    FOR EACH ROW
    WHEN ( new.id_detaliu IS NULL )
BEGIN
    :new.id_detaliu := detalii_analize_id_detaliu_seq.nextval;
END;
/

CREATE SEQUENCE detalii_pacienti_id_detaliu START WITH 1 NOCACHE ORDER;

CREATE OR REPLACE TRIGGER detalii_pacienti_id_detaliu BEFORE
    INSERT ON detalii_pacienti
    FOR EACH ROW
    WHEN ( new.id_detaliu IS NULL )
BEGIN
    :new.id_detaliu := detalii_pacienti_id_detaliu.nextval;
END;
/

CREATE SEQUENCE medici_id_medic_seq START WITH 1 NOCACHE ORDER;

CREATE OR REPLACE TRIGGER medici_id_medic_trg BEFORE
    INSERT ON medici
    FOR EACH ROW
    WHEN ( new.id_medic IS NULL )
BEGIN
    :new.id_medic := medici_id_medic_seq.nextval;
END;
/

CREATE SEQUENCE pacienti_id_pacient_seq START WITH 1 NOCACHE ORDER;

CREATE OR REPLACE TRIGGER pacienti_id_pacient_trg BEFORE
    INSERT ON pacienti
    FOR EACH ROW
    WHEN ( new.id_pacient IS NULL )
BEGIN
    :new.id_pacient := pacienti_id_pacient_seq.nextval;
END;
/



-- Oracle SQL Developer Data Modeler Summary Report: 
-- 
-- CREATE TABLE                             7
-- CREATE INDEX                             1
-- ALTER TABLE                             28
-- CREATE VIEW                              0
-- ALTER VIEW                               0
-- CREATE PACKAGE                           5
-- CREATE PACKAGE BODY                      0
-- CREATE PROCEDURE                         0
-- CREATE FUNCTION                          1
-- CREATE TRIGGER                          10
-- ALTER TRIGGER                            0
-- CREATE COLLECTION TYPE                   0
-- CREATE STRUCTURED TYPE                   0
-- CREATE STRUCTURED TYPE BODY              0
-- CREATE CLUSTER                           0
-- CREATE CONTEXT                           0
-- CREATE DATABASE                          0
-- CREATE DIMENSION                         0
-- CREATE DIRECTORY                         0
-- CREATE DISK GROUP                        0
-- CREATE ROLE                              0
-- CREATE ROLLBACK SEGMENT                  0
-- CREATE SEQUENCE                          6
-- CREATE MATERIALIZED VIEW                 0
-- CREATE MATERIALIZED VIEW LOG             0
-- CREATE SYNONYM                           0
-- CREATE TABLESPACE                        0
-- CREATE USER                              0
-- 
-- DROP TABLESPACE                          0
-- DROP DATABASE                            0
-- 
-- REDACTION POLICY                         0
-- 
-- ORDS DROP SCHEMA                         0
-- ORDS ENABLE SCHEMA                       0
-- ORDS ENABLE OBJECT                       0
-- 
-- ERRORS                                   0
-- WARNINGS                                 0
